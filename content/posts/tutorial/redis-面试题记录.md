---
title: "Redis 面试题记录"
date: 2026-01-08T16:37:49+08:00
lastmod: 2026-01-08T16:37:49+08:00
author: ["wait"]
keywords: 
- 
categories:  # 没有分类界面可以不填写
- 
tags: # 标签
- 文章
description: "Redis 面试题记录"
weight:
slug: ""
draft: false # 是否为草稿
comments: true # 本页面是否显示评论
reward: true # 打赏
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
    image: "" #图片路径例如：posts/tech/123/123.png
    zoom: # 图片大小，例如填写 50% 表示原图像的一半大小
    caption: "" #图片底部描述
    alt: ""
    relative: false
---

## 1. Redis Redis有哪些数据类型 难度系数：
Redis本质上是一个Key-Value类型的内存数据库，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到 硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。 Redis的出色之处不仅仅是性能， Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说 用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因 此也可以被当作一 个功能加强版的memcached来用。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要 局限在较小数据量的高性能操作和运算上。 常用基本数据类型如下： 
● string 字符串（一个字符串类型最大存储容量为512M） 
● list 可以重复的集合 
● set 不可以重复的集合 
● hash 类似于Map 
● zset(sorted set）带分数的set 
 ## 2. Redis为什么快 难度系数：
1. 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
2.  数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的 
3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因 为可能出现死锁而导致的性能消耗
4. 使用I/O多路复用模型，非阻塞IO  
## 3.Redis数据和MySQL数据库的一致性如何实现 :
一、 延时双删策略 在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。
具体步骤是：
1）先删除缓存
2）再写数据库 
3）休眠500毫秒（根据具体的业务时间来定） 
4）再次删除缓存。 
那么，这个500毫秒怎么确定的，具体该休眠多久呢？ 需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。 
当然，这种策略还要考虑 redis 和数据库主从同步的耗时。最后的写数据的休眠时间：则在读数据业务逻辑的耗时的基础上，加上几百ms即可。比如：休眠1秒。 
二、设置缓存的过期时间 从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取 新值然后回填缓存 结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。 
三、如何写完数据库后，再次删除缓存成功？ 上述的方案有一个缺点，那就是操作完数据库后，由于种种原因删除缓存失败，这时，可能就会出现数据不一致的情况。这里，我们需要提供一个保障重试的方案。
 1、方案一具体流程 
（1）更新数据库数据； 
（2）缓存因为种种问题删除失败； 
（3）将需要删除的key发送至消息队列； 
（4）自己消费消息，获得需要删除的key； 
（5）继续重试删除操作，直到成功。
 然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程 序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。 
2、方案二具体流程 
（1）更新数据库数据； 
（2）数据库会将操作信息写入binlog日志当中； 
（3）订阅程序提取出所需要的数据以及key； 
（4）另起一段非业务代码，获得该信息； 
（5）尝试删除缓存操作，发现删除失败； 
（6）将这些信息发送至消息队列； 
（7）重新从消息队列中获得该数据，重试操作。  
